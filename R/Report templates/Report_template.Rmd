---
title: "`r params$report_name`"
subtitle: "`r paste0(format(Sys.Date(), '%B %d'),', ', lubridate::year(Sys.Date()))`"
date: 
output: 
  word_document:
      reference_docx: style_template.docx
      toc: true
      toc_depth: 2
params:
  stations: stations
  report_name: report_name
  image_path: image_path
  report_type: report_type
  level_zoom: level_zoom
  zoom_days: zoom_days
  meteogram: meteogram
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyhydat)
library(tidyhydat.ws)
source("../Levels_with_returns_mASL.R")
source("../Hydrometric_Flow.R")
data("return_periods")
data("spatial_stns")
```

```{r Get station data, echo=FALSE, results='asis', message=FALSE}
levelData <- list()

for(i in stations) {
  #Get the level data
  levelData[[i]] <- daily_level_data(
    station_number = i,
    extract_realtime = TRUE,
    select_years = lubridate::year(Sys.Date()),
    level_zoom = TRUE
  )
  
  #Level data processing
  startYearLevel <-
    min(lubridate::year(levelData$tidyData[[1]]$Date), na.rm = T)
  todayLevel <-
    levelData$tidyData[[3]]$Value[levelData$tidyData[[3]]$Date == Sys.Date()]
  todayLevelPerc <-
    round(levelData$tidyData[[3]]$prctile[levelData$tidyData[[3]]$Date == Sys.Date()], 2)
  yesterdayLevel <-
    levelData$tidyData[[3]]$Value[levelData$tidyData[[3]]$Date == (Sys.Date() -
                                                                     1)]
  twodayLevel <-
    levelData$tidyData[[3]]$Value[levelData$tidyData[[3]]$Date == (Sys.Date() -
                                                                     2)]
  threedayLevel <-
    levelData$tidyData[[3]]$Value[levelData$tidyData[[3]]$Date == (Sys.Date() -
                                                                     3)]
  fourdayLevel <-
    levelData$tidyData[[3]]$Value[levelData$tidyData[[3]]$Date == (Sys.Date() -
                                                                     4)]
  fivedayLevel <-
    levelData$tidyData[[3]]$Value[levelData$tidyData[[3]]$Date == (Sys.Date() -
                                                                     5)]
  sixdayLevel <-
    levelData$tidyData[[3]]$Value[levelData$tidyData[[3]]$Date == (Sys.Date() -
                                                                     6)]
  weekLevel <-
    levelData$tidyData[[3]]$Value[levelData$tidyData[[3]]$Date == (Sys.Date() -
                                                                     7)]
  
  tbl <- data.frame(
      `Station name` = stringr::str_to_title(station_info$STATION_NAME),
      ID = i,
      `Start year` = startYearLevel,
      `Today percent historic` = todayLevelPerc,
      Today = todayLevel,
      Yesterday = yesterdayLevel,
      `24 hr change` = todayLevel - yesterdayLevel,
      `Two days ago` = twodayLevel,
      `Three days ago` = threedayLevel,
      `72 hr change` = todayLevel - threedayLevel,
      `Four days ago` = fourdayLevel,
      `Five days ago` = fivedayLevel,
      `Six days ago` = sixdayLevel,
      `One week ago` = weekLevel,
      `One week change` = todayLevel - weekLevel,
      `Datum elevation` = as.numeric(tidyhydat::hy_stn_datum_conv(i)[1, 4])
    )
  
  info[[i]] <- tbl #add each station information to a list, later made into a table
  
}


flowData <- list()

```

```{r Levels table, echo=FALSE, results='asis', message=FALSE}

levelsTable <- dplyr::bind_rows(info)[c(1,3:5,7, 10, 15,16)]
names(levelsTable) <- gsub("\\.", " ", names(levelsTable))
names(levelsTable) <- gsub("X", "", names(levelsTable))

knitr::kable(levelsTable, caption="Summary of water levels and level changes in meters:", digits=3)
```


# Current Status and Observations

[Enter update here]

\newpage

# Hydrometric Station Data

Water level and/or flow data is pulled from [historical](https://wateroffice.ec.gc.ca/mainmenu/historical_data_index_e.html) and [real-time](https://wateroffice.ec.gc.ca/mainmenu/real_time_data_index_e.html) hydrometric data published by the Government of Canada. Return intervals are plotted where available, represting two, ten, one hundred and two hundred year return intervals. All elevations are in reference to the Canadian Geodetic Vertical Datum of 1928 (CGVD28).

```{r Station info table, echo=FALSE, results='asis', message=FALSE}

stationInfo <- lapply(stations, function(x) tidyhydat::hy_stations(x)[c(2,1,7,8)]) %>%
  purrr::reduce(dplyr::bind_rows) %>% 
  plyr::rename(c("STATION_NAME"="Station Name", "STATION_NUMBER"="ID", "LATITUDE"="Latitude", "LONGITUDE"="Longitude"))

stationInfo$`Station Name` <- stringr::str_to_title(stationInfo$`Station Name`)

knitr::kable(stationInfo, digits=3, caption="These are the stations contained in this report:")

```

\newpage

```{r Generate plots and basic stats, echo=FALSE, fig.height=4, fig.width=7, message=FALSE, warning=FALSE, results='asis'}

info <- list()
for(i in stations) {
  
  station_info <- tidyhydat::hy_stations(i)
  if(is.na(station_info$STATION_NUMBER[1])==FALSE){
    tryCatch ( {
      cat("  \n## ", station_info$STATION_NAME," (Station ", i,")  \n")
      
      if (report_type %in% c("Both", "Level", "both", "level")){
        tryCatch ({
          datum_na <- is.na(as.numeric(tidyhydat::hy_stn_datum_conv(i)[1,4])) #different text if no datum
          
          cat("  \n### Level  \n")
          cat("  \n The current level is ", round(todayLevel,2),(if(datum_na==FALSE) {"meters above sea level"} else {"meters relative to station zero"})," which corresponds to the ", todayLevelPerc, " percentile of historic levels for this station. Since yesterday, the level has ", ifelse(todayLevel<yesterdayLevel, "decreased", "increased"), " by ", round(abs(todayLevel-yesterdayLevel), 3)," meters.  \nLevel data collection began in ", startYearLevel, " and the historic data are ", spatstat.utils::percentage(sum(stats::complete.cases(levelData$tidyData[[1]]))/nrow(levelData$tidyData[[1]])), " complete.  \n")
          
          #Level data plotting
          levelPlot <- daily_level_plot(station_number = i,
                                        complete_year = levelData$tidyData[[2]],
                                        plot_years_df = levelData$tidyData[[3]],
                                        dummy_year_df = levelData$tidyData[[4]])
          print(levelPlot)
          cat("  \n")
          
          #Plot zoomed-in level data
          if (level_zoom == TRUE){
            cat("  \n### Level (last", zoom_days, " days)")
            zoomPlot <- zoom_level_plot(station_number = i,
                                        complete_year = levelData$tidyData[[2]],
                                        plot_years_df = levelData$tidyData[[3]],
                                        dummy_year_df = levelData$tidyData[[4]],
                                        zoom_data = levelData$recent_level,
                                        zoom_days = zoom_days)
            print(zoomPlot)
            cat("  \n")
          }
        },
        error=function(e) {
          cat("  \n### Level")
          cat("  \n Station ", i, " does not appear to have real-time level data right now.  \n")})
      } # End of if "level" or "both" selected statement

      
      cat("  \n")
      
      if (stringr::str_detect(station_info$STATION_NAME, "LAKE")==FALSE){ #Lakes don't have flow measurements!
        if (report_type %in% c("Both", "Flow", "both", "flow")){
          tryCatch ({
            #Get the flow data
            flowData <- flow_data(
              station_number = i,
              extract_realtime = TRUE,
              select_years = lubridate::year(Sys.Date()))
            #Flow data processing
            startYearFlow <- min(lubridate::year(flowData[[1]]$Date), na.rm = T)
            todayFlow <- flowData[[3]]$Value[flowData[[3]]$Date==Sys.Date()]
            todayFlowPerc <- round(flowData[[3]]$prctile[flowData[[3]]$Date==Sys.Date()],2)
            yesterdayFlow <- flowData[[3]]$Value[flowData[[3]]$Date==(Sys.Date()-1)]
            cat("  \n### Flow")
            cat("\n The current flow rate is ", round(todayFlow,2), " cubic meters per second which corresponds to the ", todayFlowPerc, " percentile of historic flow volume for this station. Since yesterday, the level has ", ifelse(todayFlow<yesterdayFlow, "decreased", "increased"), " by ", round(abs(todayFlow-yesterdayFlow), 3)," cubic meters per second.  \nFlow data collection began in ", startYearFlow, " and the historic data are ", spatstat.utils::percentage(sum(stats::complete.cases(flowData[[1]]))/nrow(flowData[[1]])), " complete.")
            #Flow data plotting
            flowPlot <- flow_plot(station_number = i,
                                  complete_year = flowData[[2]],
                                  plot_years_df = flowData[[3]],
                                  dummy_year_df = flowData[[4]])
            print(flowPlot)
            cat("  \n")
            },
          error = function(e) {
            cat("  \n### Flow")
            cat("  \n Station ", i, " does not appear to have real-time flow (discharge) data right now. \n")})
        } #End of if flow or both selected
      } #End of if statement that is "LAKE" dependent
      
      cat("\n\\newpage\n")
    }, 
    
    error= function(e) {})
    
  } else {#End of if loop
   cat("\n\\newpage\n") 
   cat("## ", tidyhydat::hy_stations(i)$STATION_NAME, " Station ", i)
   cat("  \n Station ", i, " could not be found in the WSC tidyhydat database.\n")
   cat("\n\\newpage\n")

  }
} #End of For loop

cat("  \n")
```

\newpage

# Recent precipitation

The following images represent precipitation in and around Yukon. Each image integrates precipitation (from observations and remote sensing) over the 24 hours prior to the image's valid date/time (Yukon time).

```{r HRDPA, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, fig.height=4.15, fig.width=7, results='asis'}

#using the imager::load.image method instead of the standard knitr::include_graphics because include_graphics just won't work with the network drive.

setwd("//cs-fs2/cs-data/PS/Weather/WeatherFiles/Common/Grads_images/sumRDPA/hrdpa/24/")
wxfiles<- list.files()
par(mar=c(0,0,0,0)) #sets the plot margins to 0 - important

imager::load.image(wxfiles[length(wxfiles)]) %>% imager::crop.borders(nx=0, ny=18) %>% plot(axes=FALSE)

cat("  \n  \n  ")
imager::load.image(wxfiles[length(wxfiles)-2]) %>% imager::crop.borders(nx=0, ny=18) %>% plot(axes=FALSE)


```

```{r Meteograms, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, fig.height=8.8, fig.width=7.5, results='asis'}
if (meteogram==TRUE){
  cat("  \n# Relevant forecast(s)  \n")

  stationCoords <- sf::st_as_sf(stationInfo, coords=c("Longitude", "Latitude"), crs=4326) %>% 
    sf::st_set_crs(4326) %>%
    sf::st_transform(3579)
  
  meteoStns <- sf::st_as_sf(dplyr::filter(spatial_stns[,c(1,3,7,8)], Type == "Meteogram"), coords=c("Longitude", "Latitude"), crs=4326) %>%
    sf::st_set_crs(4326) %>%
    sf::st_transform(3579)
  
  buffers <- sf::st_buffer(stationCoords, dist = 150000) #150 km buffer
  
  meteos <- as.data.frame(meteoStns[lengths(sf::st_intersects(meteoStns, buffers)) > 0,]) #subset meteoStns according to the meteoStns that return TRUE for intersection
  
  
# plot <- ggplot() +
#   geom_sf(data=stationCoords, col="red") +
#   geom_sf(data=meteoStns, col="blue") +
#   geom_sf(data=buffers, fill=NA) +
#   theme_minimal()
  
  dateTimeUTC <- format(Sys.time(), "%Y%m%d")

  par(mar=c(0,0,0,0)) #sets the plot margins to 0 - important
  
  for (i in meteos$Meteogram.code) {
    cat("  \n")
    imager::load.image(paste0("https://collaboration.cmc.ec.gc.ca/cmc/ensemble/data2/combine/images/", dateTimeUTC, "00_054@007_E1_", i, "_I_NAEFS@EPSGRAMS_tt@surf@nt@pr@ws@surf_360.png")) %>% plot(axes=FALSE)
    cat("  \n")
  }
}

```

\newpage

# Still Images

```{r echo=FALSE, fig.height=4, fig.width=7, message=FALSE, warning=FALSE, results='asis'}
#This section will contain auto-generated images, selected based on the stations(s) selected.

```

```{r echo=FALSE, fig.height=4, fig.width=7, message=FALSE, warning=FALSE, results='asis'}
#This section will contain images in a folder specified by the user, if applicable
if (is.null(image_path)!=TRUE){
  cat("  \n# Other Relevant Images")

}

```

---
title: "`r paste0(params$report_name, ' ', lubridate::year(Sys.Date()))`"
subtitle: " <br>"
date: "Prepared on `r Sys.Date()`"
output: 
  word_document:
      reference_docx: style_template.docx
      toc: true
      toc_depth: 2
params:
  stations: stations
  report_name: report_name
  image_path: image_path
  report_type: report_type
  level_zoom: level_zoom
  zoom_days: zoom_days
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyhydat)
library(tidyhydat.ws)
source("../Levels_with_returns_mASL.R")
source("../Hydrometric_Flow.R")
data("../data/return_periods")
```

\newpage

This report was generated by the Yukon Government Department of Environment (Water Resources Branch) based on data pulled from the [Real-Time Hydrometric Data](https://wateroffice.ec.gc.ca/mainmenu/real_time_data_index_e.html) published by the Government of Canada. This report is based on data downloaded at `r .POSIXct(Sys.time(), tz="America/Whitehorse")` Yukon time.

<br>

<br>

# Current Status and Observations

[Enter update here]

\newpage

# Station data

Water level and flow data is listed below in order of historical importance to flooding (for ready-made reports), or in the order specified in the report request.

Water level elevations are in reference to the Canadian Geodetic Vertical Datum of 1928 (CGVD28). Note that significant differences exist between this datum and the more recent CGVD2013!

\newpage

```{r Generate reports, echo=FALSE, fig.height=4, fig.width=7, message=FALSE, warning=FALSE, results='asis'}

for(i in stations) {
  
  station_info <- tidyhydat::hy_stations(i)
  if(is.na(station_info$STATION_NUMBER[1])==FALSE){
    tryCatch ( {
      cat("  \n## ", station_info$STATION_NAME," (Station ", i,")  \n")
      cat("\n This station is located in ", station_info$PROV_TERR_STATE_LOC, " at longitude ", round(station_info$LONGITUDE, 2), ", latitude ", round(station_info$LATITUDE,2), ".  \n")
      
      if (report_type %in% c("Both", "Level", "both", "level")){
        tryCatch ({
          #Get the level data
          levelData <- daily_level_data(
            station_number = i,
            extract_realtime = TRUE,
            select_years = lubridate::year(Sys.Date()))
          
          #Level data processing
          startYearLevel <- min(lubridate::year(levelData[[1]]$Date), na.rm = T)
          todayLevel <- levelData[[3]]$Value[levelData[[3]]$Date==Sys.Date()]
          todayLevelPerc <- round(levelData[[3]]$prctile[levelData[[3]]$Date==Sys.Date()],2)
          yesterdayLevel <- levelData[[3]]$Value[levelData[[3]]$Date==(Sys.Date()-1)]
          
          cat("  \n### Level  \n")
          
          #Level data plotting
          levelPlot <- daily_level_plot(station_number = i,
                                        complete_year = levelData[[2]],
                                        plot_years_df = levelData[[3]],
                                        dummy_year_df = levelData[[4]])
          print(levelPlot)
          
          #Plot zoomed-in level data
          
          
          cat("  \n The current level is ", round(todayLevel,2)," meters above sea level which corresponds to the ", todayLevelPerc, " percentile of historic levels for this station. Since yesterday, the level has ", ifelse(todayLevel<yesterdayLevel, "decreased", "increased"), " by ", round(abs(todayLevel-yesterdayLevel), 3)," meters.  \nLevel data collection began in ", startYearLevel, " and the historic data are ", spatstat.utils::percentage(sum(stats::complete.cases(levelData[[1]]))/nrow(levelData[[1]])), " complete.  \n")
        },
        error=function(e) {
          cat("  \n### Level")
          cat("  \n Station ", i, " does not appear to have real-time level data right now.  \n")})
      } # End of if "level" or "both" selected statement

      
      cat("  \n")
      
      if (stringr::str_detect(station_info$STATION_NAME, "LAKE")==FALSE){ #Lakes don't have flow measurements!
        if (report_type %in% c("Both", "Flow", "both", "flow")){
          tryCatch ({
            #Get the flow data
            flowData <- flow_data(
              station_number = i,
              extract_realtime = TRUE,
              select_years = lubridate::year(Sys.Date()))
            #Flow data processing
            startYearFlow <- min(lubridate::year(flowData[[1]]$Date), na.rm = T)
            todayFlow <- flowData[[3]]$Value[flowData[[3]]$Date==Sys.Date()]
            todayFlowPerc <- round(flowData[[3]]$prctile[flowData[[3]]$Date==Sys.Date()],2)
            yesterdayFlow <- flowData[[3]]$Value[flowData[[3]]$Date==(Sys.Date()-1)]
            cat("  \n### Flow")
            cat("\n")
            #Flow data plotting
            flowPlot <- flow_plot(station_number = i,
                                  complete_year = flowData[[2]],
                                  plot_years_df = flowData[[3]],
                                  dummy_year_df = flowData[[4]])
            print(flowPlot)
            
            cat("\n The current flow rate is ", round(todayFlow,2), " cubic meters per second which corresponds to the ", todayFlowPerc, " percentile of historic flow volume for this station. Since yesterday, the level has ", ifelse(todayFlow<yesterdayFlow, "decreased", "increased"), " by ", round(abs(todayFlow-yesterdayFlow), 3)," cubic meters per second.  \nFlow data collection began in ", startYearFlow, " and the historic data are ", spatstat.utils::percentage(sum(stats::complete.cases(flowData[[1]]))/nrow(flowData[[1]])), " complete.")
            },
          error = function(e) {
            cat("  \n### Flow")
            cat("  \n Station ", i, " does not appear to have real-time flow (discharge) data right now. \n")})
        } #End of if flow or both selected
      } #End of if statement that is "LAKE" dependent
      
      cat("\n\\newpage\n")
    }, 
    
    error= function(e) {})
    
  } else {#End of if loop
   cat("\n\\newpage\n") 
   cat("## ", tidyhydat::hy_stations(i)$STATION_NAME, " Station ", i)
   cat("  \n Station ", i, " could not be found in the WSC tidyhydat database.\n")
   cat("\n\\newpage\n")
  }
} #End of For loop
```

# Weather Forecasts and Products

```{r}
#This section will generate weather products depending on the station locations(s). For example, Marsh Lake would get a forecast for Whitehorse and weather products for southern lakes.

```

\newpage

# Still Images

```{r}
#This section will contain auto-generated images, selected based on the stations(s) selected. This section might exist only for the pre-made reports and not the custom reports, tbd.
```

## Other images

```{r}

```

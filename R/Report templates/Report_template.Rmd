---
title: "`r params$report_name`"
subtitle: "`r paste0(format(Sys.Date(), '%B %d'),', ', lubridate::year(Sys.Date()))`"
date: 
output: 
  word_document:
      reference_docx: style_template.docx
      toc: true
      toc_depth: 2
params:
  stations: stations
  report_name: report_name
  image_path: image_path
  report_type: report_type
  level_zoom: level_zoom
  zoom_days: zoom_days
  meteogram: meteogram
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyhydat)
library(tidyhydat.ws)
source("../Levels_with_returns_mASL.R")
source("../Hydrometric_Flow.R")
data("return_periods")
data("spatial_stns")
```

# Current Status and Observations

[Enter update here]

\newpage

# Station data

Water level and/or flow data is pulled from [historical](https://wateroffice.ec.gc.ca/mainmenu/historical_data_index_e.html) and [real-time](https://wateroffice.ec.gc.ca/mainmenu/real_time_data_index_e.html) hydrometric data published by the Government of Canada. All elevations are in reference to the Canadian Geodetic Vertical Datum of 1928 (CGVD28).

```{r Station info table, echo=FALSE, results='asis', message=FALSE}

table <- lapply(stations, function(x) tidyhydat::hy_stations(x)[c(2,1,7,8)]) %>%
  purrr::reduce(dplyr::bind_rows) %>% 
  plyr::rename(c("STATION_NAME"="Station Name", "STATION_NUMBER"="ID", "LATITUDE"="Latitude", "LONGITUDE"="Longitude"))

table$`Station Name` <- stringr::str_to_title(table$`Station Name`)

knitr::kable(table, digits=3, format="pipe", caption="These are the stations contained in this report:")

```

\newpage

```{r Generate plots and basic stats, echo=FALSE, fig.height=4, fig.width=7, message=FALSE, warning=FALSE, results='asis'}

for(i in stations) {
  
  station_info <- tidyhydat::hy_stations(i)
  if(is.na(station_info$STATION_NUMBER[1])==FALSE){
    tryCatch ( {
      cat("  \n## ", station_info$STATION_NAME," (Station ", i,")  \n")
      cat("\n This station is located in ", station_info$PROV_TERR_STATE_LOC, " at longitude ", round(station_info$LONGITUDE, 2), ", latitude ", round(station_info$LATITUDE,2), ".  \n")
      
      if (report_type %in% c("Both", "Level", "both", "level")){
        tryCatch ({
          #Get the level data
          levelData <- daily_level_data(
            station_number = i,
            extract_realtime = TRUE,
            select_years = lubridate::year(Sys.Date()),
            level_zoom = TRUE)
          
          #Level data processing
          startYearLevel <- min(lubridate::year(levelData$tidyData[[1]]$Date), na.rm = T)
          todayLevel <- levelData$tidyData[[3]]$Value[levelData$tidyData[[3]]$Date==Sys.Date()]
          todayLevelPerc <- round(levelData$tidyData[[3]]$prctile[levelData$tidyData[[3]]$Date==Sys.Date()],2)
          yesterdayLevel <- levelData$tidyData[[3]]$Value[levelData$tidyData[[3]]$Date==(Sys.Date()-1)]
          
          cat("  \n### Level  \n")
          cat("  \n The current level is ", round(todayLevel,2)," meters above sea level which corresponds to the ", todayLevelPerc, " percentile of historic levels for this station. Since yesterday, the level has ", ifelse(todayLevel<yesterdayLevel, "decreased", "increased"), " by ", round(abs(todayLevel-yesterdayLevel), 3)," meters.  \nLevel data collection began in ", startYearLevel, " and the historic data are ", spatstat.utils::percentage(sum(stats::complete.cases(levelData$tidyData[[1]]))/nrow(levelData$tidyData[[1]])), " complete.  \n")
          
          #Level data plotting
          levelPlot <- daily_level_plot(station_number = i,
                                        complete_year = levelData$tidyData[[2]],
                                        plot_years_df = levelData$tidyData[[3]],
                                        dummy_year_df = levelData$tidyData[[4]])
          print(levelPlot)
          cat("  \n")
          
          #Plot zoomed-in level data
          if (level_zoom == TRUE){
            cat("  \n### Level (last", zoom_days, " days)")
            zoomPlot <- zoom_level_plot(station_number = i,
                                        complete_year = levelData$tidyData[[2]],
                                        plot_years_df = levelData$tidyData[[3]],
                                        dummy_year_df = levelData$tidyData[[4]],
                                        zoom_data = levelData$recent_level,
                                        zoom_days = zoom_days)
            print(zoomPlot)
            cat("  \n")
          }
        },
        error=function(e) {
          cat("  \n### Level")
          cat("  \n Station ", i, " does not appear to have real-time level data right now.  \n")})
      } # End of if "level" or "both" selected statement

      
      cat("  \n")
      
      if (stringr::str_detect(station_info$STATION_NAME, "LAKE")==FALSE){ #Lakes don't have flow measurements!
        if (report_type %in% c("Both", "Flow", "both", "flow")){
          tryCatch ({
            #Get the flow data
            flowData <- flow_data(
              station_number = i,
              extract_realtime = TRUE,
              select_years = lubridate::year(Sys.Date()))
            #Flow data processing
            startYearFlow <- min(lubridate::year(flowData[[1]]$Date), na.rm = T)
            todayFlow <- flowData[[3]]$Value[flowData[[3]]$Date==Sys.Date()]
            todayFlowPerc <- round(flowData[[3]]$prctile[flowData[[3]]$Date==Sys.Date()],2)
            yesterdayFlow <- flowData[[3]]$Value[flowData[[3]]$Date==(Sys.Date()-1)]
            cat("  \n### Flow")
            cat("\n The current flow rate is ", round(todayFlow,2), " cubic meters per second which corresponds to the ", todayFlowPerc, " percentile of historic flow volume for this station. Since yesterday, the level has ", ifelse(todayFlow<yesterdayFlow, "decreased", "increased"), " by ", round(abs(todayFlow-yesterdayFlow), 3)," cubic meters per second.  \nFlow data collection began in ", startYearFlow, " and the historic data are ", spatstat.utils::percentage(sum(stats::complete.cases(flowData[[1]]))/nrow(flowData[[1]])), " complete.")
            #Flow data plotting
            flowPlot <- flow_plot(station_number = i,
                                  complete_year = flowData[[2]],
                                  plot_years_df = flowData[[3]],
                                  dummy_year_df = flowData[[4]])
            print(flowPlot)
            cat("  \n")
            },
          error = function(e) {
            cat("  \n### Flow")
            cat("  \n Station ", i, " does not appear to have real-time flow (discharge) data right now. \n")})
        } #End of if flow or both selected
      } #End of if statement that is "LAKE" dependent
      
      cat("\n\\newpage\n")
    }, 
    
    error= function(e) {})
    
  } else {#End of if loop
   cat("\n\\newpage\n") 
   cat("## ", tidyhydat::hy_stations(i)$STATION_NAME, " Station ", i)
   cat("  \n Station ", i, " could not be found in the WSC tidyhydat database.\n")
   cat("\n\\newpage\n")
  }
} #End of For loop
```

\newpage

# Recent precipitation

The following images represent precipitation in and around Yukon. Each image integrates precipitation (from observations and remote sensing) over the 24 hours prior to the image's valid date/time (Yukon time).

```{r HRDPA, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, fig.height=4.15, fig.width=7, results='asis'}

#using the imager::load.image method instead of the standard knitr::include_graphics because include_graphics just won't work with the network drive.

setwd("//cs-fs2/cs-data/PS/Weather/WeatherFiles/Common/Grads_images/sumRDPA/hrdpa/24/")
wxfiles<- list.files()
par(mar=c(0,0,0,0)) #sets the plot margins to 0 - important

imager::load.image(wxfiles[length(wxfiles)]) %>% imager::crop.borders(nx=0, ny=18) %>% plot(axes=FALSE)

cat("  \n  \n  ")
imager::load.image(wxfiles[length(wxfiles)-2]) %>% imager::crop.borders(nx=0, ny=18) %>% plot(axes=FALSE)

#imager::load.image(wxfiles[length(wxfiles)-2]) %>% plot(axes=FALSE)
#imager::load.image(wxfiles[length(wxfiles)-3]) %>% plot(axes=FALSE)
#imager::load.image(wxfiles[length(wxfiles)-4]) %>% plot(axes=FALSE)

```

```{r Meteograms, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, fig.height=8.2, fig.width=7.5, results='asis'}
if (meteogram==TRUE){
  cat("  \n# Location-specific forecast(s)")
  cat("  \nThe following meteograms were selected from 10 possible forecast locations across the territory to include only those within a 200km radius of the Water Survey of Canada station(s) listed earlier in this report.  \n")
  
  par(mar=c(0,0,0,0)) #sets the plot margins to 0 - important
  imager::load.image("https://collaboration.cmc.ec.gc.ca/cmc/ensemble/data2/combine/images/2022042200_054@007_E1_yxy_I_NAEFS@EPSGRAMS_tt@surf@nt@pr@ws@surf_360.png") %>% plot(axes=FALSE)
}

```

# Still Images

```{r echo=FALSE, fig.height=4, fig.width=7, message=FALSE, warning=FALSE, results='asis'}
#This section will contain auto-generated images, selected based on the stations(s) selected.

```

```{r echo=FALSE, fig.height=4, fig.width=7, message=FALSE, warning=FALSE, results='asis'}
#This section will contain images in a folder specified by the user, if applicable
if (is.null(image_path)!=TRUE){
  cat("  \n# Other Relevant Images")

}

```
